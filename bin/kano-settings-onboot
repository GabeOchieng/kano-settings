#!/usr/bin/env python

# kano-settings-onboot
#
# Copyright (C) 2014-2018 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#
# Kano OS settings-related script executed at bootup.
#
# It ensures that the following characteristics are configured correctly:
#   1. Corrupt /boot/config.txt file
#   2. Launches OS into Safe Mode
#   3. Removes configurations made by an image built with NOOBS
#   4. The default browser is set accordingly (Chromium or Midori)
#   5. Correct ALSA volume levels on P0 CKC speaker
#   6. Lower default resolution for added performance
#
# When changes that require a reboot to take effect were made, it calls onto
# the kano-checked-reboot script to do so.


"""
kano-settings-onboot Kano OS settings-related script executed at bootup.

Usage:
    kano-settings-onboot [options]

Options:
    -f, --force     Reconfigure settings even when the status says it's not needed.
    -s, --dry-run   Execute the script, but do not apply any changes.
    -h, --help      Show this message.
"""


import time
import os
import sys
import docopt
import traceback

# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

from kano.utils.shell import run_cmd
from kano.utils.hardware import get_rpi_model, get_board_property, get_cpu_id
from kano.logging import logger
from kano_peripherals.wrappers.detection import is_ck2_pro, get_ck2_pro_version

from kano_peripherals.wrappers.detection import CKC_V_1_1_0

from kano_settings.system.display import get_status, get_edid_name, \
    get_edid, list_supported_modes, override_models, compare_and_set_full_range, \
    compare_and_set_overscan, compare_and_set_optimal_resolution, is_screen_kit, \
    get_screen_value
from kano_settings.system.boot_config.boot_config_filter import Filter
from kano_settings.boot_config import get_config_value, set_config_value, \
    remove_noobs_defaults, end_config_transaction, check_corrupt_config
from kano_settings.system.audio import is_HDMI, set_to_HDMI, restart_alsa, \
    set_alsa_config_max_dB

from kano_settings.system.audio import DEFAULT_CKC_V1_MAX_DB
from kano_settings.paths import SYSTEM_FLAGS_DIR, CKC_V1_ONBOOT_VOLUME_FLAG, \
    DISPLAY_ROTATE_GLOBAL_FLAG
from kano_settings.return_codes import RC_SUCCESS, RC_WRONG_PERMISSIONS, RC_INCORRECT_ARGS, \
    RC_EDID_NO_MODEL, RC_EDID_NO_STATUS, RC_EDID_NO_SUPPORTED, RC_NO_EDID


def main(args):

    force_mode = args['--force']
    dry_run = args['--dry-run']

    reboot_required = False

    # Check for corrupt config file.
    if check_corrupt_config():
        logger.warn('Found corrupt config file! Restored to default.')
        end_config_transaction()
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # because they duplicate our config entries and override them and
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info('Removed NOOBS config.txt defaults.')
        reboot_required = True

    # TODO: Is this still required?
    ensure_correct_browser(dry_run=dry_run)

    # Correct the maximum volume gain for CKC.
    ensure_correct_volume_levels(dry_run=dry_run)

    # If necessary, write /boot/cpuid.txt
    write_cpu_id()

    # Prevent the LXDE login screen from appearing
    try:
        # FIXME: Kano Settings shouldn't really depend on Kano Init
        from kano_init.utils import ensure_lightdm_conf
        ensure_lightdm_conf()
    except ImportError:
        logger.warn('Could not load Kano Init to check LightDm existence')

    # Gather and log data about the current screen.
    # screen_data = get_screen_information(dry_run=dry_run)
    # if verbose or dump_mode:
    #     print json.dumps(screen_data, indent=4)

    ensure_screen_kit_rotation_global()

    # Lower the screen preferred resolution.
    (rv, rc) = ensure_optimal_screen_resolution(dry_run=dry_run, force_mode=force_mode)
    reboot_required = reboot_required or rv
    if rc != RC_SUCCESS:
        return rc

    # ... and reboot if needed.
    if reboot_required:
        logger.info('Made changes that require a reboot.')
        end_config_transaction()
        reboot(dry_run=dry_run)

    return rc or RC_SUCCESS


def write_cpu_id():
    # Get the unit CPU Serial number and send it, save a local copy
    cpuid = get_cpu_id()
    cpuid_filename_boot = '/boot/cpuid.txt'
    utc_time = time.asctime(time.gmtime(time.time()))

    if os.path.isfile(cpuid_filename_boot):
        pass
    else:
        try:
            with open(cpuid_filename_boot, 'w') as f:
                f.write('RaspberryPI model: {}\n{}\n{}\n'.format(
                    get_rpi_model(),
                    utc_time,
                    cpuid))
        except:
            logger.error('Error writing boot cpuid')


def ensure_correct_browser(dry_run=False):
    """
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    """
    browser_link = 'x-www-browser'

    model = get_rpi_model()
    arch = get_board_property(model, 'arch')

    chromium_support = arch not in ['armv6']
    browser = 'chromium-browser' if chromium_support else 'epiphany-browser'

    logger.info("Set browser to be: {}".format(browser))
    if not dry_run:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))


def ensure_correct_volume_levels(dry_run=False):
    """
    Sets the default max_dB option in ALSA for CKCv1 only once.
    """
    was_set_once = os.path.exists(CKC_V1_ONBOOT_VOLUME_FLAG)
    if was_set_once:
        return

    is_ckc = is_ck2_pro(with_dbus=False)
    if not is_ckc:
        return

    ckc_version = get_ck2_pro_version()
    changes = False

    if ckc_version and ckc_version < CKC_V_1_1_0:
        logger.debug('On CKC v1, setting lower ALSA max_dB only once')

        if not dry_run:
            changes = set_alsa_config_max_dB(DEFAULT_CKC_V1_MAX_DB)

            if not os.path.exists(SYSTEM_FLAGS_DIR):
                os.makedirs(os.path.dirname(SYSTEM_FLAGS_DIR))
            open(CKC_V1_ONBOOT_VOLUME_FLAG, 'a').close()

    if changes:
        restart_alsa()


# def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    """
    TODO: Decide what to do with this.

    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    """
    # info = {
    #     "edid": get_edid(),
    #     "model": get_model(),
    #     "status": get_status(),
    #     "supported": list_supported_modes(stringify=False)
    # }

    # if not dry_run:
    #     with open(screen_log_path, 'w') as f:
    #         json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    # return info


def ensure_screen_kit_rotation_global():
    """
    Ensure the screen kit orientation setting is also set globally.

    This simply mirrors the display_rotate option for the current SK to the
    global space for the unlikely case where an SK loses its EDID.
    """
    try:
        was_set_once = os.path.exists(DISPLAY_ROTATE_GLOBAL_FLAG)
        if was_set_once:
            return

        if is_screen_kit():
            rotation = get_screen_value('display_rotate')
            set_config_value('display_rotate', rotation)
            end_config_transaction()

            if not os.path.exists(SYSTEM_FLAGS_DIR):
                os.makedirs(os.path.dirname(SYSTEM_FLAGS_DIR))
            open(DISPLAY_ROTATE_GLOBAL_FLAG, 'a').close()
    except:
        logger.error(
            'ensure_screen_kit_rotation_global: {}'
            .format(traceback.format_exc())
        )


def ensure_optimal_screen_resolution(dry_run=False, force_mode=False):
    """
    Set a lower resolution than the screen preferred one.

    This is used in order to increase performance for anything GPU heavy.
    It uses EDID filters in config.txt to configure the current screen if
    it hasn't been configured already. The function preserves the display
    mode (CEA or DMT), aspect ratio, refresh rate, etc.

    Args:
        dry_run - bool run the function, but do not apply any changes
        force_mode - bool reconfigure settings even when the status says it's not needed

    Returns:
        (reboot_required, rc) - tuple of bool whether changes which require a reboot
            were made and int as a return code if something went wrong
    """
    reboot_required = False

    # If the display model cannot be retrieved it is a strong indication that
    # the screen is unflashed or the EDID is corrupt.
    model = get_edid_name()
    if not model:
        logger.error('Could not get the model of the screen. Will use config.txt defaults.')
        return (reboot_required, RC_EDID_NO_MODEL)

    # Check if the screen was already configured by looking for the hdmi_mode option
    # set for this display only.
    was_screen_configured = get_config_value(
        'hdmi_mode',
        config_filter=Filter.get_edid_filter(model),
        fallback=False,
        ignore_comments=True
    )
    if was_screen_configured and not force_mode:
        logger.debug('This screen has been configured before, skipping.')
        return (reboot_required, RC_SUCCESS)

    # Sanity checks, we need current screen status, EDID info, and list of display modes.
    status = get_status()
    if not status:
        logger.error('Could not determine current screen status, aborting.')
        return (reboot_required, RC_EDID_NO_STATUS)

    supported_modes = list_supported_modes()
    if not supported_modes:
        logger.error('Could not determine list of screen supported modes, aborting.')
        return (reboot_required, RC_EDID_NO_SUPPORTED)

    edid = get_edid()
    if not edid:
        logger.error('No EDID found. Relying on the defaults already set in config.')
        return (reboot_required, RC_NO_EDID)

    # Apply any corrections to the EDID data and set if screen is monitor.
    override_models(edid, model)
    calculate_is_monitor(edid)

    # Fix HDMI audio status.
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('HDMI audio not supported on this screen, changing to analogue.')
        if not dry_run:
            set_to_HDMI(False)

    # Calculate changes needed...
    changes = compare_and_set_full_range(edid, status, model, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    changes = compare_and_set_overscan(edid, status, model, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    changes = compare_and_set_optimal_resolution(edid, status, supported_modes, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    return (reboot_required, RC_SUCCESS)


def calculate_is_monitor(edid):
    """
    TODO: What is this for?
    """
    edid['target_full_range'] = edid['is_monitor']


def reboot(dry_run=False):
    """
    Flush logs to disk and reboot the kit.
    """
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


if __name__ == '__main__':
    logger.force_log_level('info')

    if os.getuid() != 0:
        logger.error('Program must be executed with root priviledges.')
        sys.exit(RC_WRONG_PERMISSIONS)

    try:
        args = docopt.docopt(__doc__)
    except docopt.DocoptExit:
        print __doc__
        sys.exit(RC_INCORRECT_ARGS)

    sys.exit(main(args) or RC_SUCCESS)
